name: E2E

on:
  pull_request:
    branches: [main]
  push:
    branches: [main]

concurrency:
  group: e2e-${{ github.ref }}
  cancel-in-progress: true

jobs:
  playwright:
    name: Playwright E2E
    runs-on: ubuntu-latest
    env:
      POSTGRES_DB: cleaning
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version-file: .nvmrc

      - name: Generate CI env file with required prod secrets
        run: |
          cp backend/.env.example backend/.env.e2e.ci
          python - <<'PY'
          import os
          import re
          import secrets
          from pathlib import Path

          env_path = Path("backend/.env.e2e.ci")
          text = Path("backend/app/settings.py").read_text(encoding="utf-8")
          keys = set(re.findall(r"APP_ENV=prod requires ([A-Z0-9_]+) to be set", text))
          keys.update(re.findall(r"([A-Z0-9_]+) is required when .* in prod", text))
          keys.update(
            {
              "APP_ENV",
              "AUTH_SECRET_KEY",
              "CLIENT_PORTAL_SECRET",
              "WORKER_PORTAL_SECRET",
              "METRICS_TOKEN",
              "ADMIN_BASIC_USERNAME",
              "ADMIN_BASIC_PASSWORD",
              "LEGACY_BASIC_AUTH_ENABLED",
              "ADMIN_PROXY_AUTH_ENABLED",
              "TRUST_PROXY_HEADERS",
              "TRUSTED_PROXY_CIDRS",
              "E2E_PROXY_AUTH_ENABLED",
              "E2E_PROXY_AUTH_SECRET",
            }
          )
          keys = sorted(keys)

          lines = env_path.read_text(encoding="utf-8").splitlines()
          filtered = [
            line for line in lines if not any(line.startswith(f"{key}=") for key in keys)
          ]
          admin_username = "e2e"
          admin_password = f"ci-{secrets.token_hex(32)}"
          e2e_proxy_secret = secrets.token_hex(32)
          overrides = {
            "APP_ENV": "ci",
            "ADMIN_BASIC_USERNAME": admin_username,
            "ADMIN_BASIC_PASSWORD": admin_password,
            "LEGACY_BASIC_AUTH_ENABLED": "true",
            "ADMIN_PROXY_AUTH_ENABLED": "true",
            "TRUST_PROXY_HEADERS": "true",
            "TRUSTED_PROXY_CIDRS": "172.16.0.0/12",
            "E2E_PROXY_AUTH_ENABLED": "true",
            "E2E_PROXY_AUTH_SECRET": e2e_proxy_secret,
          }
          generated = [
            f"{key}={overrides.get(key, f'ci-{secrets.token_hex(32)}')}" for key in keys
          ]
          env_path.write_text("\n".join(filtered + generated) + "\n", encoding="utf-8")

          github_env = Path(os.environ["GITHUB_ENV"])
          github_env.write_text(
            github_env.read_text(encoding="utf-8")
            + f"ADMIN_BASIC_USERNAME={admin_username}\n"
            + f"ADMIN_BASIC_PASSWORD={admin_password}\n"
            + "ADMIN_PROXY_AUTH_ENABLED=true\n"
            + "TRUST_PROXY_HEADERS=true\n"
            + "TRUSTED_PROXY_CIDRS=172.16.0.0/12\n"
            + "E2E_PROXY_AUTH_ENABLED=true\n"
            + f"E2E_PROXY_AUTH_SECRET={e2e_proxy_secret}\n"
            + "APP_ENV=ci\n"
            + "ENV_FILE=backend/.env.e2e.ci\n",
            encoding="utf-8",
          )
          PY

      - name: Verify ENV_FILE secrets are present
        run: |
          echo "ENV_FILE=$ENV_FILE"
          echo "APP_ENV=${APP_ENV}"
          echo "ADMIN_PROXY_AUTH_ENABLED=${ADMIN_PROXY_AUTH_ENABLED}"
          echo "TRUST_PROXY_HEADERS=${TRUST_PROXY_HEADERS}"
          echo "E2E_PROXY_AUTH_ENABLED=${E2E_PROXY_AUTH_ENABLED}"
          grep -q '^AUTH_SECRET_KEY=' backend/.env.e2e.ci
          grep -E '^(AUTH_SECRET_KEY|CLIENT_PORTAL_SECRET|WORKER_PORTAL_SECRET|METRICS_TOKEN|ADMIN_BASIC_USERNAME|ADMIN_BASIC_PASSWORD|LEGACY_BASIC_AUTH_ENABLED)=' backend/.env.e2e.ci \
            | sed -E 's/=.*/=<redacted>/'

      - name: Preflight env summary (no secrets)
        run: |
          echo "Env summary from backend/.env.e2e.ci:"
          grep -E '^(APP_ENV|ADMIN_PROXY_AUTH_ENABLED|TRUST_PROXY_HEADERS|E2E_PROXY_AUTH_ENABLED|TRUSTED_PROXY_CIDRS)=' backend/.env.e2e.ci

      - name: Validate E2E env file completeness
        run: |
          python - <<'PY'
          from pathlib import Path
          import re

          env_path = Path("backend/.env.e2e.ci")
          if not env_path.exists():
            raise SystemExit("backend/.env.e2e.ci missing")
          content = env_path.read_text(encoding="utf-8").strip()
          if not content:
            raise SystemExit("backend/.env.e2e.ci is empty")

          settings_text = Path("backend/app/settings.py").read_text(encoding="utf-8")
          required = set(re.findall(r"APP_ENV=prod requires ([A-Z0-9_]+) to be configured", settings_text))
          required.update(re.findall(r"APP_ENV=prod requires ([A-Z0-9_]+) to be set", settings_text))
          required.update(re.findall(r"([A-Z0-9_]+) is required when .* in prod", settings_text))
          required.update(
            {
              "AUTH_SECRET_KEY",
              "CLIENT_PORTAL_SECRET",
              "WORKER_PORTAL_SECRET",
              "METRICS_TOKEN",
              "ADMIN_BASIC_USERNAME",
              "ADMIN_BASIC_PASSWORD",
              "LEGACY_BASIC_AUTH_ENABLED",
            }
          )

          present = {
            line.split("=", 1)[0]
            for line in content.splitlines()
            if line and not line.strip().startswith("#") and "=" in line
          }
          app_env_value = next(
            (
              line.split("=", 1)[1]
              for line in content.splitlines()
              if line.startswith("APP_ENV=")
            ),
            None,
          )
          missing = sorted(required - present)
          print("E2E env keys present:", ", ".join(sorted(present)))
          print("APP_ENV:", app_env_value)
          if app_env_value != "ci":
            raise SystemExit(f"APP_ENV must be set to ci for E2E runs (got {app_env_value})")
          if missing:
            raise SystemExit(f"Missing required E2E env keys: {', '.join(missing)}")
          PY

      - name: Compose down (pre-cleanup)
        run: docker compose -f docker-compose.yml -f docker-compose.e2e.yml down -v || true

      - name: Log Docker Compose versions
        run: |
          docker compose version || true
          docker version || true

      - name: Verify E2E db command preload (source)
        run: |
          set -euo pipefail
          if [ ! -f docker-compose.yml ] || [ ! -f docker-compose.e2e.yml ]; then
            echo "Compose files missing"
            ls -la docker-compose.yml docker-compose.e2e.yml || true
            exit 1
          fi
          python - <<'PY'
          import sys

          content = open("docker-compose.e2e.yml", "r", encoding="utf-8").read().splitlines()
          if not content:
            raise SystemExit("docker-compose.e2e.yml is empty")

          def indent_of(line: str) -> int:
            return len(line) - len(line.lstrip(" "))

          services_idx = None
          services_indent = 0
          for idx, line in enumerate(content):
            if line.strip() == "services:":
              services_idx = idx
              services_indent = indent_of(line)
              break
          if services_idx is None:
            print("services block not found")
            print("\n".join(content[:120]))
            raise SystemExit(1)

          db_idx = None
          db_indent = services_indent + 2
          for idx in range(services_idx + 1, len(content)):
            line = content[idx]
            if not line.strip():
              continue
            if indent_of(line) == services_indent and line.strip().endswith(":"):
              break
            if indent_of(line) == db_indent and line.strip() == "db:":
              db_idx = idx
              break

          if db_idx is None:
            print("db service block not found in docker-compose.e2e.yml")
            print("\n".join(content[services_idx:services_idx + 120]))
            raise SystemExit(1)

          db_block = [content[db_idx]]
          for idx in range(db_idx + 1, len(content)):
            line = content[idx]
            if not line.strip():
              db_block.append(line)
              continue
            if indent_of(line) <= db_indent and line.strip().endswith(":"):
              break
            db_block.append(line)

          command_tokens: list[str] = []
          command_block_indent = None
          for idx, line in enumerate(db_block):
            stripped = line.strip()
            if stripped.startswith("command:"):
              command_block_indent = indent_of(line)
              after = stripped.removeprefix("command:").strip()
              if after:
                command_tokens.append(after)
              for next_line in db_block[idx + 1:]:
                if not next_line.strip():
                  continue
                next_indent = indent_of(next_line)
                if next_indent <= command_block_indent:
                  break
                candidate = next_line.strip()
                if candidate.startswith("- "):
                  command_tokens.append(candidate.removeprefix("- ").strip())
              break

          print("Resolved db.command tokens:", command_tokens if command_tokens else "<missing>")
          if not command_tokens:
            print("---- db block ----")
            print("\n".join(db_block))
            raise SystemExit(1)

          joined = " ".join(command_tokens)
          if "shared_preload_libraries=pg_stat_statements" not in joined:
            print("db.command missing shared_preload_libraries=pg_stat_statements")
            print("---- db block ----")
            print("\n".join(db_block))
            raise SystemExit(1)
          if "pg_stat_statements.track=all" not in joined:
            print("db.command missing pg_stat_statements.track=all")
            print("---- db block ----")
            print("\n".join(db_block))
            raise SystemExit(1)
          PY

      - name: Compose config (diagnostic only)
        run: |
          docker compose -f docker-compose.yml -f docker-compose.e2e.yml config > compose_config_stdout.yml 2> compose_config_stderr.log || true
          if [ ! -s compose_config_stdout.yml ]; then
            echo "docker compose config produced empty output (diagnostic only)"
            cat compose_config_stderr.log || true
          fi

      - name: Compose up (db + redis)
        run: |
          set +e
          docker compose -f docker-compose.yml -f docker-compose.e2e.yml up -d --wait --wait-timeout 300 db redis
          status=$?
          docker compose -f docker-compose.yml -f docker-compose.e2e.yml ps || true
          docker compose -f docker-compose.yml -f docker-compose.e2e.yml logs --no-color --tail=300 db || true
          exit $status

      - name: Wait for DB healthy
        run: |
          set -euo pipefail
          db_container_id=$(docker compose -f docker-compose.yml -f docker-compose.e2e.yml ps -q db)
          if [ -z "$db_container_id" ]; then
            echo "DB container not found."
            exit 1
          fi
          deadline=$((SECONDS + 180))
          while true; do
            health=$(docker inspect "$db_container_id" --format '{{if .State.Health}}{{.State.Health.Status}}{{else}}unknown{{end}}')
            if [ "$health" = "healthy" ]; then
              echo "DB is healthy."
              break
            fi
            if [ "$health" = "unhealthy" ]; then
              echo "DB is unhealthy."
              docker compose -f docker-compose.yml -f docker-compose.e2e.yml ps || true
              docker compose -f docker-compose.yml -f docker-compose.e2e.yml logs --no-color db --tail=300 || true
              docker inspect "$db_container_id" --format '{{json .State.Health}}' || true
              exit 1
            fi
            if [ $SECONDS -ge $deadline ]; then
              echo "Timed out waiting for DB health."
              docker compose -f docker-compose.yml -f docker-compose.e2e.yml ps || true
              docker compose -f docker-compose.yml -f docker-compose.e2e.yml logs --no-color db --tail=300 || true
              docker inspect "$db_container_id" --format '{{json .State.Health}}' || true
              exit 1
            fi
            sleep 3
          done

      - name: Validate pg_stat_statements preload
        run: |
          set -euo pipefail
          preload=$(docker compose -f docker-compose.yml -f docker-compose.e2e.yml exec -T db \
            psql -U "$POSTGRES_USER" -d "$POSTGRES_DB" -tA -c "SHOW shared_preload_libraries;")
          echo "shared_preload_libraries=$preload"
          if ! echo "$preload" | grep -q "pg_stat_statements"; then
            echo "pg_stat_statements is not preloaded. Check docker-compose.e2e.yml db command overrides."
            docker compose -f docker-compose.yml -f docker-compose.e2e.yml logs --no-color --tail=300 db || true
            exit 1
          fi

      - name: Verify DB readiness via SQL
        run: |
          set -euo pipefail
          docker compose -f docker-compose.yml -f docker-compose.e2e.yml exec -T db \
            psql -U "$POSTGRES_USER" -d "$POSTGRES_DB" -c "select 1;"

      - name: Compose up (api + web + jobs)
        run: |
          set +e
          docker compose -f docker-compose.yml -f docker-compose.e2e.yml up -d --wait --wait-timeout 300 api web jobs
          status=$?
          docker compose -f docker-compose.yml -f docker-compose.e2e.yml ps || true
          docker compose -f docker-compose.yml -f docker-compose.e2e.yml logs --no-color --tail=400 api || true
          docker compose -f docker-compose.yml -f docker-compose.e2e.yml logs --no-color --tail=300 db || true
          api_container_id=$(docker compose -f docker-compose.yml -f docker-compose.e2e.yml ps -q api)
          if [ -n "$api_container_id" ]; then
            docker inspect "$api_container_id" --format '{{json .State.Health}}' || true
          fi
          exit $status

      - name: Compose diagnostics (post-up)
        run: |
          docker compose -f docker-compose.yml -f docker-compose.e2e.yml ps || true
          echo ""
          docker compose -f docker-compose.yml -f docker-compose.e2e.yml config || true
          echo ""
          docker compose -f docker-compose.yml -f docker-compose.e2e.yml port api 8000 || true
          echo ""
          docker compose -f docker-compose.yml -f docker-compose.e2e.yml logs --no-color --tail=400 api || true
          echo ""
          docker compose -f docker-compose.yml -f docker-compose.e2e.yml logs --no-color --tail=300 db || true
          echo ""
          docker compose -f docker-compose.yml -f docker-compose.e2e.yml exec -T api env | grep '^APP_ENV=' || true
          echo ""
          docker compose -f docker-compose.yml -f docker-compose.e2e.yml exec -T api \
            python -c "import os; print('AUTH_SECRET_KEY set:', bool(os.getenv('AUTH_SECRET_KEY')))" || true
          echo ""
          docker compose -f docker-compose.yml -f docker-compose.e2e.yml exec -T api alembic current || true
          docker compose -f docker-compose.yml -f docker-compose.e2e.yml exec -T api alembic heads || true

      - name: Wait for stack readiness
        run: |
          wait_on() {
            local url=$1
            local name=$2
            if ! curl -fsS --max-time 2 --retry 60 --retry-connrefused --retry-delay 2 "$url" >/dev/null; then
              echo "Timed out waiting for ${name} at ${url}"
              docker compose -f docker-compose.yml -f docker-compose.e2e.yml ps || true
              docker compose -f docker-compose.yml -f docker-compose.e2e.yml logs --no-color --tail=400 api || true
              docker compose -f docker-compose.yml -f docker-compose.e2e.yml logs --no-color --tail=300 db || true
              docker compose -f docker-compose.yml -f docker-compose.e2e.yml exec -T api alembic current || true
              docker compose -f docker-compose.yml -f docker-compose.e2e.yml exec -T api alembic heads || true
              return 1
            fi
          }
          wait_on "http://127.0.0.1:8000/healthz" "api healthz"
          wait_on "http://127.0.0.1:8000/readyz" "api readyz"
          wait_on "http://127.0.0.1:3000/" "web"

      - name: Preflight admin auth
        run: |
          python - <<'PY'
          import hmac
          import hashlib
          import os
          import time
          import urllib.error
          import urllib.request

          user = os.environ["ADMIN_BASIC_USERNAME"]
          email = os.environ.get("E2E_PROXY_ADMIN_EMAIL", user)
          roles = os.environ.get("E2E_PROXY_ADMIN_ROLES", "admin")
          secret = os.environ["E2E_PROXY_AUTH_SECRET"]
          ts = str(int(time.time()))
          canonical = f"{user}|{email}|{roles}|{ts}"
          signature = hmac.new(secret.encode(), canonical.encode(), hashlib.sha256).hexdigest()
          req = urllib.request.Request("http://127.0.0.1:8000/v1/admin/profile")
          req.add_header("X-Proxy-Admin-User", user)
          req.add_header("X-Proxy-Admin-Email", email)
          req.add_header("X-Proxy-Admin-Roles", roles)
          req.add_header("X-Proxy-Admin-Timestamp", ts)
          req.add_header("X-Proxy-Admin-Signature", signature)
          try:
            urllib.request.urlopen(req, timeout=5).read()
          except urllib.error.HTTPError as exc:
            reason = exc.headers.get("X-Admin-Auth-Fail-Reason")
            print(f"Admin proxy auth preflight failed: {exc}")
            if reason:
              print(f"X-Admin-Auth-Fail-Reason: {reason}")
            raise SystemExit(1) from exc
          except Exception as exc:
            raise SystemExit(f"Admin proxy auth preflight failed: {exc}") from exc
          PY

      - name: Install web dependencies
        working-directory: web
        run: npm ci

      - name: Install Playwright deps (ephemeral)
        working-directory: web
        run: npm i -D --no-save --no-package-lock @playwright/test playwright

      - name: Sanity check Playwright module resolution
        working-directory: web
        run: node -e "require.resolve('@playwright/test')"

      - name: Run Playwright tests
        working-directory: web
        env:
          PW_CHANNEL: chrome
          PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD: "1"
          PLAYWRIGHT_BASE_URL: http://127.0.0.1:3000
          PLAYWRIGHT_API_BASE_URL: http://127.0.0.1:8000
          ADMIN_BASIC_USERNAME: ${{ env.ADMIN_BASIC_USERNAME }}
          ADMIN_BASIC_PASSWORD: ${{ env.ADMIN_BASIC_PASSWORD }}
          ADMIN_PROXY_AUTH_ENABLED: ${{ env.ADMIN_PROXY_AUTH_ENABLED }}
          E2E_PROXY_AUTH_ENABLED: ${{ env.E2E_PROXY_AUTH_ENABLED }}
          E2E_PROXY_AUTH_SECRET: ${{ env.E2E_PROXY_AUTH_SECRET }}
        run: |
          PW_CHANNEL=chrome PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD=1 \
          PLAYWRIGHT_BASE_URL=http://127.0.0.1:3000 \
          PLAYWRIGHT_API_BASE_URL=http://127.0.0.1:8000 \
          ADMIN_BASIC_USERNAME="$ADMIN_BASIC_USERNAME" \
          ADMIN_BASIC_PASSWORD="$ADMIN_BASIC_PASSWORD" \
          ADMIN_PROXY_AUTH_ENABLED="$ADMIN_PROXY_AUTH_ENABLED" \
          E2E_PROXY_AUTH_ENABLED="$E2E_PROXY_AUTH_ENABLED" \
          E2E_PROXY_AUTH_SECRET="$E2E_PROXY_AUTH_SECRET" \
          npx playwright test --config e2e/playwright.config.ts

      - name: Collect compose diagnostics
        if: always()
        run: |
          {
            echo "== docker compose ps =="
            docker compose -f docker-compose.yml -f docker-compose.e2e.yml ps
            echo ""
            echo "== docker compose config =="
            docker compose -f docker-compose.yml -f docker-compose.e2e.yml config
            echo ""
            echo "== docker compose port api 8000 =="
            docker compose -f docker-compose.yml -f docker-compose.e2e.yml port api 8000 || true
            echo ""
            echo "== docker compose logs api (tail) =="
            docker compose -f docker-compose.yml -f docker-compose.e2e.yml logs --no-color api --tail=400 || true
            echo ""
            echo "== docker compose logs db (tail) =="
            docker compose -f docker-compose.yml -f docker-compose.e2e.yml logs --no-color db --tail=300 || true
            echo ""
            echo "== docker inspect db health =="
            db_container_id=$(docker compose -f docker-compose.yml -f docker-compose.e2e.yml ps -q db)
            if [ -n "$db_container_id" ]; then
              docker inspect "$db_container_id" --format '{{json .State.Health}}' || true
            else
              echo "db container missing"
            fi
            echo ""
            echo "== alembic status (api) =="
            docker compose -f docker-compose.yml -f docker-compose.e2e.yml exec -T api alembic current || true
            docker compose -f docker-compose.yml -f docker-compose.e2e.yml exec -T api alembic heads || true
          } > e2e-compose-diagnostics.log

      - name: Upload Playwright report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: playwright-report
          path: web/playwright-report/**

      - name: Upload Playwright test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: playwright-test-results
          path: web/test-results/**

      - name: Upload compose diagnostics
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: e2e-compose-diagnostics
          path: e2e-compose-diagnostics.log

      - name: Compose down
        if: always()
        run: docker compose -f docker-compose.yml -f docker-compose.e2e.yml down -v
