name: E2E

on:
  pull_request:
    branches: [main]
  push:
    branches: [main]

concurrency:
  group: e2e-${{ github.ref }}
  cancel-in-progress: true

jobs:
  playwright:
    name: Playwright E2E
    runs-on: ubuntu-latest
    env:
      POSTGRES_DB: cleaning
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres

    steps:
      - name: Checkout code
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4

      - name: Set up Node.js
        uses: actions/setup-node@49933ea5288caeca8642d1e84afbd3f7d6820020 # v4
        with:
          node-version: 20

      - name: Disable corepack
        run: corepack disable || true

      - name: Set up pnpm
        uses: pnpm/action-setup@c5ba7f7862a0f64c1b1a05fbac13e0b8e86ba08c # v4
        with:
          version: 10.18.3

      - name: Generate CI env file with required prod secrets
        run: |
          cp backend/.env.example backend/.env.e2e.ci
          python - <<'PY'
          import os
          import re
          import secrets
          from pathlib import Path

          env_path = Path("backend/.env.e2e.ci")
          text = Path("backend/app/settings.py").read_text(encoding="utf-8")
          keys = set(re.findall(r"APP_ENV=prod requires ([A-Z0-9_]+) to be set", text))
          keys.update(re.findall(r"([A-Z0-9_]+) is required when .* in prod", text))
          keys.update(
            {
              "AUTH_SECRET_KEY",
              "CLIENT_PORTAL_SECRET",
              "WORKER_PORTAL_SECRET",
              "METRICS_TOKEN",
              "RATE_LIMIT_PER_MINUTE",
              "ADMIN_BASIC_USERNAME",
              "ADMIN_BASIC_PASSWORD",
              "LEGACY_BASIC_AUTH_ENABLED",
              "APP_ENV",
              "CORS_ORIGINS",
              "ADMIN_PROXY_AUTH_ENABLED",
              "ADMIN_PROXY_AUTH_REQUIRED",
              "ADMIN_PROXY_AUTH_SECRET",
              "ADMIN_PROXY_AUTH_E2E_ENABLED",
              "ADMIN_PROXY_AUTH_E2E_SECRET",
              "TRUST_PROXY_HEADERS",
              "TRUSTED_PROXY_IPS",
              "TRUSTED_PROXY_CIDRS",
            }
          )
          keys = sorted(keys)

          lines = env_path.read_text(encoding="utf-8").splitlines()
          filtered = [
            line for line in lines if not any(line.startswith(f"{key}=") for key in keys)
          ]
          admin_username = "e2e"
          admin_password = f"ci-{secrets.token_hex(32)}"
          overrides = {
            "APP_ENV": "ci",
            "CORS_ORIGINS": '["http://localhost:3000", "http://127.0.0.1:3000"]',
            "ADMIN_BASIC_USERNAME": admin_username,
            "ADMIN_BASIC_PASSWORD": admin_password,
            "LEGACY_BASIC_AUTH_ENABLED": "false",
            "RATE_LIMIT_PER_MINUTE": "1200",
            "ADMIN_PROXY_AUTH_ENABLED": "true",
            "ADMIN_PROXY_AUTH_REQUIRED": "true",
            "ADMIN_PROXY_AUTH_SECRET": f"ci-proxy-{secrets.token_hex(32)}",
            "ADMIN_PROXY_AUTH_E2E_ENABLED": "true",
            "ADMIN_PROXY_AUTH_E2E_SECRET": f"ci-e2e-{secrets.token_hex(32)}",
            "TRUST_PROXY_HEADERS": "true",
            "TRUSTED_PROXY_IPS": "",
            "TRUSTED_PROXY_CIDRS": "127.0.0.1/32,::1/128,172.16.0.0/12",
          }
          generated = [
            f"{key}={overrides.get(key, f'ci-{secrets.token_hex(32)}')}" for key in keys
          ]
          env_path.write_text("\n".join(filtered + generated) + "\n", encoding="utf-8")

          github_env = Path(os.environ["GITHUB_ENV"])
          github_env.write_text(
            github_env.read_text(encoding="utf-8")
            + f"ADMIN_BASIC_USERNAME={admin_username}\n"
            + f"ADMIN_BASIC_PASSWORD={admin_password}\n"
            + f"ADMIN_PROXY_AUTH_ENABLED={overrides['ADMIN_PROXY_AUTH_ENABLED']}\n"
            + f"ADMIN_PROXY_AUTH_REQUIRED={overrides['ADMIN_PROXY_AUTH_REQUIRED']}\n"
            + f"ADMIN_PROXY_AUTH_SECRET={overrides['ADMIN_PROXY_AUTH_SECRET']}\n"
            + f"ADMIN_PROXY_AUTH_E2E_ENABLED={overrides['ADMIN_PROXY_AUTH_E2E_ENABLED']}\n"
            + f"ADMIN_PROXY_AUTH_E2E_SECRET={overrides['ADMIN_PROXY_AUTH_E2E_SECRET']}\n"
            + f"ADMIN_PROXY_AUTH_ROLE=admin\n"
            + f"ADMIN_PROXY_AUTH_E2E_USER={admin_username}\n"
            + f"ADMIN_PROXY_AUTH_E2E_EMAIL={admin_username}@example.com\n"
            + f"ADMIN_PROXY_AUTH_E2E_ROLES=admin\n"
            + f"TRUST_PROXY_HEADERS={overrides['TRUST_PROXY_HEADERS']}\n"
            + f"TRUSTED_PROXY_CIDRS={overrides['TRUSTED_PROXY_CIDRS']}\n"
            + "ENV_FILE=backend/.env.e2e.ci\n",
            encoding="utf-8",
          )
          PY

      - name: Verify ENV_FILE secrets are present
        run: |
          echo "ENV_FILE=$ENV_FILE"
          grep -q '^AUTH_SECRET_KEY=' backend/.env.e2e.ci
          grep -E '^(AUTH_SECRET_KEY|CLIENT_PORTAL_SECRET|WORKER_PORTAL_SECRET|METRICS_TOKEN|ADMIN_BASIC_USERNAME|ADMIN_BASIC_PASSWORD|LEGACY_BASIC_AUTH_ENABLED|ADMIN_PROXY_AUTH_ENABLED|ADMIN_PROXY_AUTH_REQUIRED|ADMIN_PROXY_AUTH_SECRET|ADMIN_PROXY_AUTH_E2E_ENABLED|ADMIN_PROXY_AUTH_E2E_SECRET|TRUST_PROXY_HEADERS|TRUSTED_PROXY_IPS|TRUSTED_PROXY_CIDRS|APP_ENV)=' backend/.env.e2e.ci \
            | sed -E 's/=.*/=<redacted>/'

      - name: Validate E2E env file completeness
        run: |
          python - <<'PY'
          from pathlib import Path
          import re

          env_path = Path("backend/.env.e2e.ci")
          if not env_path.exists():
            raise SystemExit("backend/.env.e2e.ci missing")
          content = env_path.read_text(encoding="utf-8").strip()
          if not content:
            raise SystemExit("backend/.env.e2e.ci is empty")

          settings_text = Path("backend/app/settings.py").read_text(encoding="utf-8")
          required = set(re.findall(r"APP_ENV=prod requires ([A-Z0-9_]+) to be configured", settings_text))
          required.update(re.findall(r"APP_ENV=prod requires ([A-Z0-9_]+) to be set", settings_text))
          required.update(re.findall(r"([A-Z0-9_]+) is required when .* in prod", settings_text))
          required.update(
            {
              "AUTH_SECRET_KEY",
              "CLIENT_PORTAL_SECRET",
              "WORKER_PORTAL_SECRET",
              "METRICS_TOKEN",
              "ADMIN_BASIC_USERNAME",
              "ADMIN_BASIC_PASSWORD",
              "LEGACY_BASIC_AUTH_ENABLED",
              "APP_ENV",
              "CORS_ORIGINS",
              "ADMIN_PROXY_AUTH_ENABLED",
              "ADMIN_PROXY_AUTH_REQUIRED",
              "ADMIN_PROXY_AUTH_SECRET",
              "ADMIN_PROXY_AUTH_E2E_ENABLED",
              "ADMIN_PROXY_AUTH_E2E_SECRET",
              "TRUST_PROXY_HEADERS",
              "TRUSTED_PROXY_IPS",
              "TRUSTED_PROXY_CIDRS",
            }
          )

          present = {
            line.split("=", 1)[0]
            for line in content.splitlines()
            if line and not line.strip().startswith("#") and "=" in line
          }
          missing = sorted(required - present)
          print("E2E env keys present:", ", ".join(sorted(present)))
          if missing:
            raise SystemExit(f"Missing required E2E env keys: {', '.join(missing)}")
          PY

      - name: Check Alembic merge parents
        run: python backend/scripts/check_alembic_merge_parents.py

      - name: Compose down (pre-cleanup)
        run: docker compose -f docker-compose.yml -f docker-compose.e2e.yml down -v || true

      - name: Log Docker Compose versions
        run: |
          docker compose version || true
          docker version || true

      - name: Create diagnostic files directory
        shell: bash
        run: |
          set -euo pipefail

          # Guaranteed writable location on GitHub runner
          DIAG_DIR="${RUNNER_TEMP:-/tmp}/e2e-diagnostics-${GITHUB_RUN_ID:-local}-${GITHUB_RUN_ATTEMPT:-0}"

          # If something exists there as a file, remove it so mkdir works
          if [ -f "$DIAG_DIR" ]; then
            rm -f "$DIAG_DIR"
          fi

          mkdir -p "$DIAG_DIR"
          echo "DIAG_DIR=$DIAG_DIR" >> "$GITHUB_ENV"

          echo "Diagnostics dir: $DIAG_DIR"
          ls -la "$DIAG_DIR"

      - name: Verify E2E db command preload (source)
        run: |
          set -euo pipefail
          if [ ! -f docker-compose.yml ] || [ ! -f docker-compose.e2e.yml ]; then
            echo "Compose files missing"
            ls -la docker-compose.yml docker-compose.e2e.yml || true
            exit 1
          fi
          python - <<'PY'
          import sys

          content = open("docker-compose.e2e.yml", "r", encoding="utf-8").read().splitlines()
          if not content:
            raise SystemExit("docker-compose.e2e.yml is empty")

          def indent_of(line: str) -> int:
            return len(line) - len(line.lstrip(" "))

          services_idx = None
          services_indent = 0
          for idx, line in enumerate(content):
            if line.strip() == "services:":
              services_idx = idx
              services_indent = indent_of(line)
              break
          if services_idx is None:
            print("services block not found")
            print("\n".join(content[:120]))
            raise SystemExit(1)

          db_idx = None
          db_indent = services_indent + 2
          for idx in range(services_idx + 1, len(content)):
            line = content[idx]
            if not line.strip():
              continue
            if indent_of(line) == services_indent and line.strip().endswith(":"):
              break
            if indent_of(line) == db_indent and line.strip() == "db:":
              db_idx = idx
              break

          if db_idx is None:
            print("db service block not found in docker-compose.e2e.yml")
            print("\n".join(content[services_idx:services_idx + 120]))
            raise SystemExit(1)

          db_block = [content[db_idx]]
          for idx in range(db_idx + 1, len(content)):
            line = content[idx]
            if not line.strip():
              db_block.append(line)
              continue
            if indent_of(line) <= db_indent and line.strip().endswith(":"):
              break
            db_block.append(line)

          command_tokens: list[str] = []
          command_block_indent = None
          for idx, line in enumerate(db_block):
            stripped = line.strip()
            if stripped.startswith("command:"):
              command_block_indent = indent_of(line)
              after = stripped.removeprefix("command:").strip()
              if after:
                command_tokens.append(after)
              for next_line in db_block[idx + 1:]:
                if not next_line.strip():
                  continue
                next_indent = indent_of(next_line)
                if next_indent <= command_block_indent:
                  break
                candidate = next_line.strip()
                if candidate.startswith("- "):
                  command_tokens.append(candidate.removeprefix("- ").strip())
              break

          print("Resolved db.command tokens:", command_tokens if command_tokens else "<missing>")
          if not command_tokens:
            print("---- db block ----")
            print("\n".join(db_block))
            raise SystemExit(1)

          joined = " ".join(command_tokens)
          if "shared_preload_libraries=pg_stat_statements" not in joined:
            print("db.command missing shared_preload_libraries=pg_stat_statements")
            print("---- db block ----")
            print("\n".join(db_block))
            raise SystemExit(1)
          if "pg_stat_statements.track=all" not in joined:
            print("db.command missing pg_stat_statements.track=all")
            print("---- db block ----")
            print("\n".join(db_block))
            raise SystemExit(1)
          PY

      - name: YAML guardrail (detect duplicate keys)
        run: |
          echo "=== Checking for duplicate service keys in docker-compose.e2e.yml ==="
          # Quick check for duplicate top-level service definitions
          for key in caddy api web db jobs redis; do
            count=$(grep -E "^  ${key}:\s*$" docker-compose.e2e.yml 2>/dev/null | wc -l)
            if [ "$count" -gt 1 ]; then
              echo "ERROR: Found $count definitions of '$key:' in docker-compose.e2e.yml"
              echo "=== Line numbers with '$key:' ==="
              grep -n "^  ${key}:" docker-compose.e2e.yml || true
              echo "=== Context around duplicates ==="
              nl -ba docker-compose.e2e.yml | grep -A5 -B5 "^  ${key}:" || true
            fi
          done
          echo "=== YAML guardrail check complete ==="

      - name: Validate compose config (fail-fast)
        run: |
          set -euo pipefail
          echo "=== Validating docker-compose configuration ==="
          if ! docker compose -f docker-compose.yml -f docker-compose.e2e.yml config > compose_config_stdout.yml 2> compose_config_stderr.log; then
            echo "ERROR: docker compose config failed!"
            echo ""
            echo "=== stderr output ==="
            cat compose_config_stderr.log || true
            echo ""
            echo "=== docker-compose.e2e.yml with line numbers (lines 1-100) ==="
            nl -ba docker-compose.e2e.yml | head -100
            echo ""
            echo "=== Searching for duplicate 'caddy:' definitions ==="
            grep -n "caddy:" docker-compose.e2e.yml || true
            echo ""
            echo "=== Full docker-compose.e2e.yml ==="
            nl -ba docker-compose.e2e.yml
            exit 1
          fi
          echo "docker compose config validation passed"

      - name: Compose up (db + redis)
        run: |
          set +e
          docker compose -f docker-compose.yml -f docker-compose.e2e.yml up -d --wait --wait-timeout 300 db redis
          status=$?
          docker compose -f docker-compose.yml -f docker-compose.e2e.yml ps || true
          docker compose -f docker-compose.yml -f docker-compose.e2e.yml logs --no-color --tail=300 db || true
          exit $status

      - name: Wait for DB healthy
        run: |
          set -euo pipefail
          db_container_id=$(docker compose -f docker-compose.yml -f docker-compose.e2e.yml ps -q db)
          if [ -z "$db_container_id" ]; then
            echo "DB container not found."
            exit 1
          fi
          deadline=$((SECONDS + 180))
          while true; do
            health=$(docker inspect "$db_container_id" --format '{{if .State.Health}}{{.State.Health.Status}}{{else}}unknown{{end}}')
            if [ "$health" = "healthy" ]; then
              echo "DB is healthy."
              break
            fi
            if [ "$health" = "unhealthy" ]; then
              echo "DB is unhealthy."
              docker compose -f docker-compose.yml -f docker-compose.e2e.yml ps || true
              docker compose -f docker-compose.yml -f docker-compose.e2e.yml logs --no-color db --tail=300 || true
              docker inspect "$db_container_id" --format '{{json .State.Health}}' || true
              exit 1
            fi
            if [ $SECONDS -ge $deadline ]; then
              echo "Timed out waiting for DB health."
              docker compose -f docker-compose.yml -f docker-compose.e2e.yml ps || true
              docker compose -f docker-compose.yml -f docker-compose.e2e.yml logs --no-color db --tail=300 || true
              docker inspect "$db_container_id" --format '{{json .State.Health}}' || true
              exit 1
            fi
            sleep 3
          done

      - name: Validate pg_stat_statements preload
        run: |
          set -euo pipefail
          preload=$(docker compose -f docker-compose.yml -f docker-compose.e2e.yml exec -T db \
            psql -U "$POSTGRES_USER" -d "$POSTGRES_DB" -tA -c "SHOW shared_preload_libraries;")
          echo "shared_preload_libraries=$preload"
          if ! echo "$preload" | grep -q "pg_stat_statements"; then
            echo "pg_stat_statements is not preloaded. Check docker-compose.e2e.yml db command overrides."
            docker compose -f docker-compose.yml -f docker-compose.e2e.yml logs --no-color --tail=300 db || true
            exit 1
          fi

      - name: Verify DB readiness via SQL
        run: |
          set -euo pipefail
          docker compose -f docker-compose.yml -f docker-compose.e2e.yml exec -T db \
            psql -U "$POSTGRES_USER" -d "$POSTGRES_DB" -c "select 1;"

      - name: Compose up (api + web + jobs + caddy)
        run: |
          set +e
          docker compose -f docker-compose.yml -f docker-compose.e2e.yml -f docker-compose.e2e.override.yml up -d --wait --wait-timeout 300 api web jobs caddy
          status=$?
          docker compose -f docker-compose.yml -f docker-compose.e2e.yml ps || true
          docker compose -f docker-compose.yml -f docker-compose.e2e.yml logs --no-color --tail=400 api || true
          docker compose -f docker-compose.yml -f docker-compose.e2e.yml logs --no-color --tail=300 caddy || true
          docker compose -f docker-compose.yml -f docker-compose.e2e.yml logs --no-color --tail=300 db || true
          api_container_id=$(docker compose -f docker-compose.yml -f docker-compose.e2e.yml ps -q api)
          if [ -n "$api_container_id" ]; then
            docker inspect "$api_container_id" --format '{{json .State.Health}}' || true
          fi
          exit $status

      - name: Compose diagnostics (post-up)
        run: |
          docker compose -f docker-compose.yml -f docker-compose.e2e.yml ps || true
          echo ""
          docker compose -f docker-compose.yml -f docker-compose.e2e.yml config || true
          echo ""
          docker compose -f docker-compose.yml -f docker-compose.e2e.yml port api 8000 || true
          echo ""
          docker compose -f docker-compose.yml -f docker-compose.e2e.yml logs --no-color --tail=400 api || true
          echo ""
          docker compose -f docker-compose.yml -f docker-compose.e2e.yml logs --no-color --tail=300 db || true
          echo ""
          docker compose -f docker-compose.yml -f docker-compose.e2e.yml exec -T api \
            python -c "import os; print('AUTH_SECRET_KEY set:', bool(os.getenv('AUTH_SECRET_KEY')))" || true
          echo ""
          docker compose -f docker-compose.yml -f docker-compose.e2e.yml exec -T api alembic current || true
          docker compose -f docker-compose.yml -f docker-compose.e2e.yml exec -T api alembic heads || true

      - name: Wait for stack readiness
        run: |
          wait_on() {
            local url=$1
            local name=$2
            if ! curl -fsS --max-time 5 --retry 90 --retry-connrefused --retry-delay 3 "$url" >/dev/null; then
              echo "Timed out waiting for ${name} at ${url}"
              echo "--- ${name} response (if available) ---"
              curl -sS -i --max-time 5 "$url" || true
              docker compose -f docker-compose.yml -f docker-compose.e2e.yml ps || true
              docker compose -f docker-compose.yml -f docker-compose.e2e.yml logs --no-color --tail=400 api || true
              docker compose -f docker-compose.yml -f docker-compose.e2e.yml logs --no-color --tail=400 caddy || true
              docker compose -f docker-compose.yml -f docker-compose.e2e.yml logs --no-color --tail=300 web || true
              docker compose -f docker-compose.yml -f docker-compose.e2e.yml logs --no-color --tail=300 db || true
              docker compose -f docker-compose.yml -f docker-compose.e2e.yml exec -T api alembic current || true
              docker compose -f docker-compose.yml -f docker-compose.e2e.yml exec -T api alembic heads || true
              return 1
            fi
          }
          wait_on "http://127.0.0.1:3000/healthz" "api healthz (via caddy)"
          wait_on "http://127.0.0.1:3000/readyz" "api readyz (via caddy)"
          wait_on "http://127.0.0.1:3000/" "web (via caddy)"

      - name: Preflight admin auth
        run: |
          PYTHONPATH=backend python backend/scripts/e2e_admin_probe.py --url http://127.0.0.1:3000/v1/admin/profile

      - name: Verify admin endpoints via basic auth
        shell: bash
        run: |
          set -euo pipefail
          curl -fsS -u "${ADMIN_BASIC_USERNAME}:${ADMIN_BASIC_PASSWORD}" http://127.0.0.1:3000/v1/admin/profile >/dev/null
          curl -fsS -u "${ADMIN_BASIC_USERNAME}:${ADMIN_BASIC_PASSWORD}" http://127.0.0.1:3000/v1/admin/settings/features >/dev/null
          curl -fsS -u "${ADMIN_BASIC_USERNAME}:${ADMIN_BASIC_PASSWORD}" http://127.0.0.1:3000/v1/admin/users/me/ui_prefs >/dev/null

      - name: E2E admin auth probe (headers)
        shell: bash
        run: |
          set -euo pipefail

          echo "=== E2E admin auth probe (headers) ==="
          for path in /v1/admin/settings/features /v1/admin/users/me/ui_prefs; do
            echo "== ${path} =="
            # Print only a small whitelist of headers + status line
            curl -sS -D - "http://127.0.0.1:3000${path}" -o /dev/null \
              | awk 'BEGIN{IGNORECASE=1} \
                /^HTTP\// || \
                /^x-admin-auth-fail-reason:/ || \
                /^x-request-id:/ || \
                /^x-correlation-id:/ || \
                /^server:/ || \
                /^date:/ || \
                /^www-authenticate:/ \
                {print}' \
              || true
            echo
          done

      - name: Install web dependencies
        working-directory: web
        run: npm ci

      - name: Install Playwright deps (ephemeral)
        working-directory: web
        run: npm i -D --no-save --no-package-lock @playwright/test playwright

      - name: Install Playwright browsers (with ffmpeg)
        working-directory: web
        run: npx playwright install --with-deps

      - name: Sanity check Playwright module resolution
        working-directory: web
        run: node -e "require.resolve('@playwright/test')"

      - name: Run Playwright tests
        working-directory: web
        env:
          PW_CHANNEL: chrome
          PLAYWRIGHT_BASE_URL: http://127.0.0.1:3000
          PLAYWRIGHT_API_BASE_URL: http://127.0.0.1:3000
          SAAS_E2E_ACCESS_TOKEN: ${{ secrets.SAAS_E2E_ACCESS_TOKEN }}
          ADMIN_BASIC_USERNAME: ${{ env.ADMIN_BASIC_USERNAME }}
          ADMIN_BASIC_PASSWORD: ${{ env.ADMIN_BASIC_PASSWORD }}
          ADMIN_PROXY_AUTH_ENABLED: ${{ env.ADMIN_PROXY_AUTH_ENABLED }}
          ADMIN_PROXY_AUTH_REQUIRED: ${{ env.ADMIN_PROXY_AUTH_REQUIRED }}
          ADMIN_PROXY_AUTH_SECRET: ${{ env.ADMIN_PROXY_AUTH_SECRET }}
          ADMIN_PROXY_AUTH_E2E_ENABLED: ${{ env.ADMIN_PROXY_AUTH_E2E_ENABLED }}
          ADMIN_PROXY_AUTH_E2E_SECRET: ${{ env.ADMIN_PROXY_AUTH_E2E_SECRET }}
          ADMIN_PROXY_AUTH_ROLE: ${{ env.ADMIN_PROXY_AUTH_ROLE }}
          ADMIN_PROXY_AUTH_E2E_USER: ${{ env.ADMIN_PROXY_AUTH_E2E_USER }}
          ADMIN_PROXY_AUTH_E2E_EMAIL: ${{ env.ADMIN_PROXY_AUTH_E2E_EMAIL }}
          ADMIN_PROXY_AUTH_E2E_ROLES: ${{ env.ADMIN_PROXY_AUTH_E2E_ROLES }}
        run: |
          PW_CHANNEL=chrome \
          PLAYWRIGHT_BASE_URL=http://127.0.0.1:3000 \
          PLAYWRIGHT_API_BASE_URL=http://127.0.0.1:3000 \
          SAAS_E2E_ACCESS_TOKEN="$SAAS_E2E_ACCESS_TOKEN" \
          ADMIN_BASIC_USERNAME="$ADMIN_BASIC_USERNAME" \
          ADMIN_BASIC_PASSWORD="$ADMIN_BASIC_PASSWORD" \
          ADMIN_PROXY_AUTH_ENABLED="$ADMIN_PROXY_AUTH_ENABLED" \
          ADMIN_PROXY_AUTH_REQUIRED="$ADMIN_PROXY_AUTH_REQUIRED" \
          ADMIN_PROXY_AUTH_SECRET="$ADMIN_PROXY_AUTH_SECRET" \
          ADMIN_PROXY_AUTH_E2E_ENABLED="$ADMIN_PROXY_AUTH_E2E_ENABLED" \
          ADMIN_PROXY_AUTH_E2E_SECRET="$ADMIN_PROXY_AUTH_E2E_SECRET" \
          ADMIN_PROXY_AUTH_ROLE="$ADMIN_PROXY_AUTH_ROLE" \
          ADMIN_PROXY_AUTH_E2E_USER="$ADMIN_PROXY_AUTH_E2E_USER" \
          ADMIN_PROXY_AUTH_E2E_EMAIL="$ADMIN_PROXY_AUTH_E2E_EMAIL" \
          ADMIN_PROXY_AUTH_E2E_ROLES="$ADMIN_PROXY_AUTH_E2E_ROLES" \
          pnpm exec playwright test --config e2e/playwright.config.ts

      - name: Assert no unauthenticated admin probes
        if: always()
        run: |
          logs=$(docker compose -f docker-compose.yml -f docker-compose.e2e.yml logs --no-color api || true)
          if echo "$logs" | grep -q "admin_proxy_auth_required_missing_headers"; then
            echo "Detected unauthenticated admin probes in API logs."
            echo "$logs" | grep -n "admin_proxy_auth_required_missing_headers" || true
            exit 1
          fi

      - name: Collect compose diagnostics
        if: always()
        shell: bash
        run: |
          set +e  # Never fail this step

          # Use DIAG_DIR from env, fallback to local directory
          DIAG_DIR="${DIAG_DIR:-e2e-diagnostics}"
          mkdir -p "$DIAG_DIR" 2>/dev/null || true

          echo "Collecting diagnostics to: $DIAG_DIR"

          # Save numbered docker-compose.e2e.yml for debugging
          nl -ba docker-compose.e2e.yml > "$DIAG_DIR/docker-compose.e2e.nl.txt" 2>&1 || true

          # Save compose config (may fail if YAML is invalid)
          docker compose -f docker-compose.yml -f docker-compose.e2e.yml config > "$DIAG_DIR/e2e-compose.config.txt" 2>&1 || {
            echo "=== Compose config failed (YAML likely invalid) ===" >> "$DIAG_DIR/e2e-compose.config.txt"
          }

          # Save full compose logs
          docker compose -f docker-compose.yml -f docker-compose.e2e.yml logs --no-color --timestamps > "$DIAG_DIR/e2e-compose.log" 2>&1 || true

          # Build detailed diagnostics log
          {
            echo "== Timestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ) =="
            echo ""
            echo "== docker compose ps =="
            docker compose -f docker-compose.yml -f docker-compose.e2e.yml ps 2>&1 || echo "(ps failed)"
            echo ""
            echo "== docker compose config =="
            docker compose -f docker-compose.yml -f docker-compose.e2e.yml config 2>&1 || echo "(config failed - see e2e-compose.config.txt)"
            echo ""
            echo "== docker compose port api 8000 =="
            docker compose -f docker-compose.yml -f docker-compose.e2e.yml port api 8000 2>&1 || echo "(port check failed)"
            echo ""
            echo "== docker compose logs api (tail) =="
            docker compose -f docker-compose.yml -f docker-compose.e2e.yml logs --no-color api --tail=400 2>&1 || echo "(api logs failed)"
            echo ""
            echo "== docker compose logs caddy (tail) =="
            docker compose -f docker-compose.yml -f docker-compose.e2e.yml logs --no-color caddy --tail=300 2>&1 || echo "(caddy logs failed)"
            echo ""
            echo "== docker compose logs web (tail) =="
            docker compose -f docker-compose.yml -f docker-compose.e2e.yml logs --no-color web --tail=200 2>&1 || echo "(web logs failed)"
            echo ""
            echo "== docker compose logs db (tail) =="
            docker compose -f docker-compose.yml -f docker-compose.e2e.yml logs --no-color db --tail=300 2>&1 || echo "(db logs failed)"
            echo ""
            echo "== docker inspect db health =="
            db_container_id=$(docker compose -f docker-compose.yml -f docker-compose.e2e.yml ps -q db 2>/dev/null)
            if [ -n "$db_container_id" ]; then
              docker inspect "$db_container_id" --format '{{json .State.Health}}' 2>&1 || echo "(inspect failed)"
            else
              echo "db container missing or compose ps failed"
            fi
            echo ""
            echo "== alembic status (api) =="
            docker compose -f docker-compose.yml -f docker-compose.e2e.yml exec -T api alembic current 2>&1 || echo "(alembic current failed)"
            docker compose -f docker-compose.yml -f docker-compose.e2e.yml exec -T api alembic heads 2>&1 || echo "(alembic heads failed)"
          } > "$DIAG_DIR/e2e-compose-diagnostics.log" 2>&1 || true

          # Copy to root for backward compatibility
          cp "$DIAG_DIR/e2e-compose-diagnostics.log" e2e-compose-diagnostics.log 2>/dev/null || true

          echo "Diagnostics collection complete"

      - name: Upload Playwright report
        if: always()
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4
        with:
          name: playwright-report
          path: web/playwright-report/**
          if-no-files-found: ignore

      - name: Upload Playwright test results
        if: always()
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4
        with:
          name: playwright-test-results
          path: web/test-results/**
          if-no-files-found: ignore

      - name: Upload compose diagnostics
        if: always()
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4
        with:
          name: e2e-compose-diagnostics
          path: e2e-compose-diagnostics.log
          if-no-files-found: ignore

      - name: Upload enhanced diagnostics
        if: always()
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4
        with:
          name: e2e-diagnostics-bundle
          path: |
            ${{ env.DIAG_DIR }}
            e2e-diagnostics/
            compose_config_stdout.yml
            compose_config_stderr.log
          if-no-files-found: ignore

      - name: Compose down (non-fatal)
        if: always()
        run: |
          echo "=== Tearing down compose stack ==="
          docker compose -f docker-compose.yml -f docker-compose.e2e.yml down -v || {
            echo "WARNING: Compose down failed (non-fatal, likely due to YAML parse error)"
            echo "Attempting to stop containers individually..."
            docker compose -f docker-compose.yml -f docker-compose.e2e.yml ps -q 2>/dev/null | xargs -r docker stop || true
            docker compose -f docker-compose.yml -f docker-compose.e2e.yml ps -q 2>/dev/null | xargs -r docker rm -f || true
            true
          }
          echo "=== Teardown complete ==="
