#!/usr/bin/env python3
from __future__ import annotations

import argparse
import asyncio
import json
import os
import sys
from datetime import datetime, timezone
from pathlib import Path

from sqlalchemy.ext.asyncio import async_sessionmaker, create_async_engine

ROOT = Path(__file__).resolve().parents[1]
if str(ROOT) not in sys.path:
    sys.path.insert(0, str(ROOT))

from app.domain.access_review import reporting as access_review_reporting
from app.settings import settings


def _parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Generate quarterly access review evidence bundles.")
    parser.add_argument(
        "--snapshot",
        required=True,
        help="Path to the access review snapshot JSON generated by access_review_snapshot.py.",
    )
    parser.add_argument(
        "--output-dir",
        required=True,
        help="Directory to write the evidence bundle (a subdirectory is created).",
    )
    parser.add_argument(
        "--database-url",
        default=None,
        help="Database URL to connect to. Defaults to DATABASE_URL or app.settings.",
    )
    parser.add_argument(
        "--generated-at",
        default=None,
        help="ISO-8601 timestamp for the bundle metadata (defaults to snapshot generated_at).",
    )
    parser.add_argument(
        "--signed-by",
        default=None,
        help="Optional reviewer identifier to include in metadata.json.",
    )
    return parser.parse_args()


def _resolve_database_url(cli_value: str | None) -> str:
    if cli_value:
        return cli_value
    env_value = os.getenv("DATABASE_URL")
    if env_value:
        return env_value
    return settings.database_url


def _parse_dt(value: str) -> datetime:
    parsed = datetime.fromisoformat(value.replace("Z", "+00:00"))
    if parsed.tzinfo is None:
        return parsed.replace(tzinfo=timezone.utc)
    return parsed.astimezone(timezone.utc)


def _load_snapshot(path: str) -> dict:
    with open(path, "r", encoding="utf-8") as handle:
        return json.load(handle)


def _bundle_dir(output_dir: str, snapshot: dict) -> Path:
    as_of = snapshot.get("as_of") or snapshot.get("generated_at")
    if as_of:
        as_of_dt = _parse_dt(as_of)
        timestamp = as_of_dt.strftime("%Y%m%dT%H%M%SZ")
    else:
        timestamp = datetime.now(tz=timezone.utc).strftime("%Y%m%dT%H%M%SZ")
    scope = snapshot.get("scope", "unknown")
    org_label = snapshot.get("org_id") or "global"
    return Path(output_dir) / f"access_review_evidence_{scope}_{org_label}_{timestamp}"


async def _run() -> int:
    args = _parse_args()
    snapshot = _load_snapshot(args.snapshot)

    generated_at_raw = args.generated_at or snapshot.get("generated_at") or snapshot.get("as_of")
    if not generated_at_raw:
        raise ValueError("Snapshot missing generated_at/as_of and --generated-at not provided")
    generated_at = _parse_dt(generated_at_raw)

    database_url = _resolve_database_url(args.database_url)
    engine = create_async_engine(database_url, pool_pre_ping=True)
    session_factory = async_sessionmaker(engine, expire_on_commit=False)

    async with session_factory() as session:
        audit_extract = await access_review_reporting.build_audit_extract_payload(
            session,
            snapshot,
            generated_at=generated_at,
        )

    await engine.dispose()

    bundle_dir = _bundle_dir(args.output_dir, snapshot)
    result = access_review_reporting.write_evidence_bundle(
        bundle_dir,
        snapshot=snapshot,
        audit_extract=audit_extract,
        generated_at=generated_at,
        signed_by=args.signed_by,
    )

    print(f"Evidence bundle created: {result['bundle_dir']}")
    print(f"Manifest hash: {result['manifest_hash']}")
    return 0


def main() -> int:
    try:
        return asyncio.run(_run())
    except KeyboardInterrupt:
        return 130


if __name__ == "__main__":
    raise SystemExit(main())
