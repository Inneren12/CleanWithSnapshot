{
  log {
    output file /var/log/caddy/caddy.log {
      roll_size 50MiB
      roll_keep 10
      roll_keep_for 168h
    }
  }
}

(admin_proxy) {
  # Require MFA assertion from upstream IdP/access layer
  @admin_mfa_missing not header X-Auth-MFA "true"
  respond @admin_mfa_missing "Admin access requires MFA." 403

  # Authenticate admin users at proxy level
  # Credentials are configured via environment variables:
  # - ADMIN_PROXY_AUTH_HASH_OWNER: bcrypt hash for owner user
  # - ADMIN_PROXY_AUTH_HASH_ADMIN: bcrypt hash for admin user
  # - ADMIN_PROXY_AUTH_HASH_DISPATCHER: bcrypt hash for dispatcher user
  # - ADMIN_PROXY_AUTH_HASH_VIEWER: bcrypt hash for viewer user
  basicauth {
    owner {env.ADMIN_PROXY_AUTH_HASH_OWNER}
    admin {env.ADMIN_PROXY_AUTH_HASH_ADMIN}
    dispatcher {env.ADMIN_PROXY_AUTH_HASH_DISPATCHER}
    accountant {env.ADMIN_PROXY_AUTH_HASH_ACCOUNTANT}
    viewer {env.ADMIN_PROXY_AUTH_HASH_VIEWER}
  }

  # Strip the original Authorization header to prevent backend from seeing credentials
  request_header -Authorization

  # Inject trusted proxy headers for the backend
  # The backend verifies X-Proxy-Auth-Secret matches its configured secret
  request_header -X-Auth-MFA
  request_header X-Auth-MFA "true"
  request_header X-Admin-User {http.auth.user.id}
  request_header X-Admin-Roles {http.auth.user.id}
  request_header X-Proxy-Auth-Secret {env.ADMIN_PROXY_AUTH_SECRET}

  # Prevent caching of admin responses
  header Cache-Control "no-store, no-cache, must-revalidate, private"
  header Pragma "no-cache"

  reverse_proxy api:8000 {
    transport http {
      dial_timeout 10s
      read_timeout 90s
      write_timeout 90s
    }
  }
}

http://127.0.0.1, http://localhost {
  @health path /healthz /readyz
  handle @health {
    reverse_proxy api:8000
  }

  @admin path /v1/admin /v1/admin/*
  handle @admin {
    reverse_proxy api:8000 {
      header_up -Authorization
      header_up X-Proxy-Auth-Secret {env.ADMIN_PROXY_AUTH_SECRET}
      header_up X-Admin-User {env.ADMIN_PROXY_AUTH_USER}
      header_up X-Admin-Email {env.ADMIN_PROXY_AUTH_EMAIL}
      header_up X-Admin-Roles {env.ADMIN_PROXY_AUTH_ROLES}
      header_up X-Auth-MFA {env.ADMIN_PROXY_AUTH_MFA}
    }
  }

  handle /v1/* {
    reverse_proxy api:8000
  }

  handle {
    reverse_proxy web:3000
  }
}

panidobro.com, www.panidobro.com {
  encode zstd gzip

  log {
    output file /var/log/caddy/access_web.log {
      roll_size 50MiB
      roll_keep 10
      roll_keep_for 168h
    }
    format json
  }

  handle_path /admin {
    header Cache-Control "no-store"
    redir https://api.panidobro.com/v1/admin 302
  }

  handle_path /admin/* {
    header Cache-Control "no-store"
    redir https://api.panidobro.com/v1/admin{path} 302
  }

  handle_path /grafana/* {
    @grafana_allowlist remote_ip 127.0.0.1 ::1 {env.GRAFANA_ALLOWED_IPS}
    handle @grafana_allowlist {
      reverse_proxy grafana:3000
    }
    # Optional BasicAuth protection (requires env vars, do not commit secrets).
    # handle {
    #   basicauth {env.GRAFANA_BASIC_AUTH_USER} {env.GRAFANA_BASIC_AUTH_HASH}
    #   reverse_proxy grafana:3000
    # }
    handle {
      respond "Grafana access denied." 403
    }
  }

  reverse_proxy web:3000 {
    transport http {
      dial_timeout 10s
      read_timeout 60s
      write_timeout 60s
    }
  }
}

api.panidobro.com {
  encode zstd gzip

  log {
    output file /var/log/caddy/access_api.log {
      roll_size 50MiB
      roll_keep 10
      roll_keep_for 168h
    }
    format json
  }

  @docs path /docs* /openapi.json
  header @docs -Content-Security-Policy
  header @docs Content-Security-Policy "default-src 'self'; img-src 'self' data: https://fastapi.tiangolo.com; style-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net; script-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net;"

  # Admin routes: proxy-level authentication
  # When ADMIN_PROXY_AUTH_ENABLED=true, all /v1/admin/* requests are authenticated here.
  # The backend trusts headers injected by this proxy (verified via X-Proxy-Auth-Secret).
  #
  # To enable:
  # 1. Set ADMIN_PROXY_AUTH_HASH_<USERNAME> env vars with bcrypt hashes (use `caddy hash-password`)
  # 2. Set ADMIN_PROXY_AUTH_SECRET to a shared 32+ char secret (same in backend)
  # 3. Set ADMIN_PROXY_AUTH_ENABLED=true and ADMIN_PROXY_AUTH_REQUIRED=true in backend
  #
  # Example generating password hash: caddy hash-password --plaintext 'your-password'
  @admin path /v1/admin /v1/admin/*
  handle @admin {
    # Enable allowlisting only when ADMIN_ALLOWED_IPS is non-empty.
    @admin_allowlist_enabled expression `{env.ADMIN_ALLOWED_IPS} != ""`
    @admin_ip_allowlist remote_ip 127.0.0.1 ::1 {env.ADMIN_ALLOWED_IPS}
    @admin_break_glass header X-Break-Glass-Token *

    handle @admin_allowlist_enabled {
      handle @admin_break_glass {
        import admin_proxy
      }
      handle @admin_ip_allowlist {
        import admin_proxy
      }
      respond "Admin access denied from this IP." 403
    }

    handle {
      import admin_proxy
    }
  }

  reverse_proxy api:8000 {
    header_up Authorization {header.Authorization}
    transport http {
      dial_timeout 10s
      read_timeout 90s
      write_timeout 90s
    }
  }
}
